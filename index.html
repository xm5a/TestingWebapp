<!DOCTYPE HTML>
<html lang="en">
<head>
  <!-- OpenLayers -->
  <script src="https://unpkg.com/ol/dist/ol.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/ol/ol.css">
  <!-- ol-mapbox-style -->
  <script src="https://unpkg.com/ol-mapbox-style/dist/olms.js"></script>
</head>
<body>
  <div id="map" style="width: 100%; height: 500px"></div>
  <script>
    // === Map setup ===
    const openfreemap = new ol.layer.Group();
    const initialCenter = ol.proj.fromLonLat([13.388, 52.517]);
    const map = new ol.Map({
      layers: [openfreemap],
      view: new ol.View({center: initialCenter, zoom: 9.5}),
      target: 'map'
    });
    olms.apply(openfreemap, 'https://tiles.openfreemap.org/styles/liberty');

    // === Marker setup ===
    const marker = new ol.Feature({
      geometry: new ol.geom.Point(initialCenter)
    });
    const markerStyle = new ol.style.Style({
      image: new ol.style.Icon({
        anchor: [0.5, 1],
        src: 'location.png', // Use your own icon
        scale: 0.05
      })
    });
    marker.setStyle(markerStyle);
    const vectorSource = new ol.source.Vector({ features: [marker] });
    const vectorLayer = new ol.layer.Vector({ source: vectorSource });
    map.addLayer(vectorLayer);

    // === Geofence setup ===
    const geofenceCenter = initialCenter; // Same as initial center
    const geofenceRadius = 500; // meters

    // Helper to get color-coded style
    function getGeofenceStyle(inside) {
      return new ol.style.Style({
        stroke: new ol.style.Stroke({ color: inside ? 'green' : 'red', width: 2 }),
        fill: new ol.style.Fill({ color: inside ? 'rgba(0,200,0,0.15)' : 'rgba(255,0,0,0.15)' })
      });
    }

    const geofenceFeature = new ol.Feature(new ol.geom.Circle(geofenceCenter, geofenceRadius));
    let isInside = false; // Track state for coloring
    geofenceFeature.setStyle(getGeofenceStyle(isInside));
    const geofenceLayer = new ol.layer.Vector({
      source: new ol.source.Vector({ features: [geofenceFeature] })
    });
    map.addLayer(geofenceLayer);

    // === Geofencing logic ===
    let wasInsideGeofence = false;

    navigator.geolocation.watchPosition((position) => {
      const lon = position.coords.longitude;
      const lat = position.coords.latitude;
      const userLocation = ol.proj.fromLonLat([lon, lat]);
      marker.getGeometry().setCoordinates(userLocation);
      map.getView().setCenter(userLocation);
      map.getView().setZoom(15);

      // Geofence check using real-world distance
      const circle = geofenceFeature.getGeometry();
      const distance = ol.sphere.getDistance(
        ol.proj.toLonLat(circle.getCenter()),
        [lon, lat]
      );
      const inside = distance <= circle.getRadius();

      // Update geofence color if state changes
      if (inside !== isInside) {
        geofenceFeature.setStyle(getGeofenceStyle(inside));
        isInside = inside;
      }

      if (inside && !wasInsideGeofence) {
        alert('You have entered the geofenced area!');
      } else if (!inside && wasInsideGeofence) {
        alert('You have exited the geofenced area!');
      }
      wasInsideGeofence = inside;
    }, (error) => {
      console.error('Geolocation error:', error.message);
      alert('Unable to access your location. Please enable GPS or location services.');
    });
  </script>
</body>
</html>
